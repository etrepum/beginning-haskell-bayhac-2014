<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="css/simple.css"/>
  <link rel="stylesheet" media="print" href="reveal.js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
    <title>Intro to Haskell for Erlangers</title>
    <link rel="stylesheet" href="css/slides.css"/>
    <script src="d3/d3.min.js"></script>
    <script src="js/slides.js"></script>
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="title" class="slide level1">
<h1></h1>
<h1>
    
Beginning Haskell
</h1>
<h3>
    
Bob Ippolito (<a href="https://twitter.com/etrepum"><span class="citation" data-cites="etrepum">@etrepum</span></a>)<br> BayHac 2014
</h3>
<h4>
<a href="http://bob.ippoli.to/beginning-haskell-bayhac-2014/">bob.ippoli.to/beginning-haskell-bayhac-2014</a>
</h4>
<br><br>
<h4>
<strong>Please install GHC now</strong> <a href="http://bit.ly/install-ghc">bit.ly/install-ghc</a>
</h4>

</section>
<section id="who-am-i" class="slide level1">
<h1>Who am I?</h1>
<ul>
<li>Haskell user since 2012 (ported <a href="http://exercism.io">exercism.io</a> curriculum)</li>
<li>Spending most of my time with <a href="http://www.missionbit.com/">Mission Bit</a>, teaching after school coding classes (but not in Haskell... yet)</li>
<li>Doing a bit of advising/investing in startups</li>
</ul>
</section>
<section id="haskells-appeal" class="slide level1">
<h1>Haskell's Appeal</h1>
<ul>
<li>Abstractions can often be used without penalty</li>
<li>Efficient parallel and concurrent programming</li>
<li>Type system makes maintenance easier</li>
<li>Nice syntax (not too heavy or lightweight)</li>
<li>Fantastic community &amp; ecosystem</li>
</ul>
</section>
<section id="use-the-hoogle" class="slide level1">
<h1>Use the Hoogle</h1>
<ul>
<li><a href="http://www.haskell.org/hoogle/">haskell.org/hoogle</a></li>
<li>Search for <a href="http://www.haskell.org/hoogle/?hoogle=Prelude">Prelude</a></li>
<li>The <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html">Prelude module</a> contains all of the built-in functions, types, and typeclasses</li>
<li>Most of Haskell is written in Haskell, use the source links!</li>
</ul>
</section>
<section id="haskell-syntax" class="slide level1">
<h1>Haskell Syntax</h1>
<dl>
<dt>Types</dt>
<dd>Defines types and typeclasses
</dd>
<dd><p>Constructors and record accessors become terms</p>
</dd>
<dt>Terms</dt>
<dd>Named bindings
</dd>
<dd>Instances of constructors
</dd>
<dd>Functions
</dd>
<dd><p>Control flow</p>
</dd>
</dl>
</section>
<section id="types" class="slide level1">
<h1>Types</h1>
<ul>
<li>Examples: <code>Bool</code>, <code>Int</code>, <code>[a]</code>, <code>Maybe a</code></li>
<li>Start with a capital letter</li>
<li>Defined with <code>data</code> or <code>newtype</code></li>
<li>Aliases made with <code>type</code></li>
</ul>
</section>
<section id="sum-types" class="slide level1 big-code">
<h1>Sum Types</h1>
<ul>
<li>Sum types enumerate all possible inhabitants</li>
<li>Bool has 2 possibilities, Ordering has 3, ...</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span>

<span class="kw">data</span> <span class="dt">Ordering</span> <span class="fu">=</span> <span class="dt">LT</span> <span class="fu">|</span> <span class="dt">EQ</span> <span class="fu">|</span> <span class="dt">GT</span>

<span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Definitely</span> <span class="fu">|</span> <span class="dt">Possibly</span> <span class="fu">|</span> <span class="dt">NoWay</span>

<span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="fu">...</span> <span class="fu">|</span> <span class="fu">-</span><span class="dv">1</span> <span class="fu">|</span> <span class="dv">0</span> <span class="fu">|</span> <span class="dv">1</span> <span class="fu">|</span> <span class="dv">2</span> <span class="fu">|</span> <span class="fu">...</span>

<span class="kw">data</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="fu">...</span> <span class="fu">|</span> <span class="ch">&#39;a&#39;</span> <span class="fu">|</span> <span class="ch">&#39;b&#39;</span> <span class="fu">|</span> <span class="fu">...</span></code></pre>
</section>
<section id="product-types" class="slide level1 big-code">
<h1>Product Types</h1>
<ul>
<li>Product types are like structs, with fields that contain other types</li>
<li>Choices has <code>3 * 3 == 9</code> possible inhabitants</li>
<li>Can name these fields using record syntax (defines getters automatically)</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoinFlip</span> <span class="fu">=</span> <span class="dt">CoinFlip</span> <span class="dt">Bool</span>

<span class="kw">data</span> <span class="dt">Choices</span> <span class="fu">=</span> <span class="dt">Choices</span> <span class="dt">Choice</span> <span class="dt">Choice</span>

<span class="kw">data</span> <span class="dt">Coord</span> <span class="fu">=</span> <span class="dt">Coord</span> {<span class="ot"> x ::</span> <span class="dt">Double</span>,<span class="ot"> y ::</span> <span class="dt">Double</span> }</code></pre>
</section>
<section id="sum-of-products" class="slide level1 big-code">
<h1>Sum of Products</h1>
<ul>
<li>Possibly has <code>(1 * 2) + 1</code> possibilities</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Possibly</span> <span class="fu">=</span> <span class="dt">Certainly</span> <span class="dt">Bool</span>
              <span class="fu">|</span> <span class="dt">Uncertain</span>

<span class="kw">data</span> <span class="dt">DrawCommand</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">Int</span> <span class="dt">Int</span>
                 <span class="fu">|</span> <span class="dt">Line</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>
                 <span class="fu">|</span> <span class="dt">Rect</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>

<span class="kw">data</span> <span class="dt">IntTree</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">IntTree</span> <span class="dt">IntTree</span>
             <span class="fu">|</span> <span class="dt">Leaf</span></code></pre>
</section>
<section id="abstract-data-types" class="slide level1 big-code">
<h1>Abstract Data Types</h1>
<ul>
<li>Type variables are lowercase</li>
<li><code>type</code> creates aliases (can help readability)</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>

<span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Just</span> a
             <span class="fu">|</span> <span class="dt">Nothing</span>

<span class="kw">type</span> <span class="dt">IntList</span> <span class="fu">=</span> <span class="dt">List</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">MaybeBool</span> <span class="fu">=</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</code></pre>
</section>
<section id="special-type-syntax" class="slide level1 big-code">
<h1>Special Type Syntax</h1>
<ul>
<li>Unit, Tuples, Lists, and Functions have special syntax</li>
<li>Can also be written in prefix form</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Unit</span> <span class="fu">=</span> ()

<span class="kw">type</span> <span class="dt">ListOfInt</span> <span class="fu">=</span> [<span class="dt">Int</span>]
<span class="kw">type</span> <span class="dt">ListOfInt</span> <span class="fu">=</span> [] <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">AddFun</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">AddFun</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)
<span class="kw">type</span> <span class="dt">AddFun</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>) <span class="dt">Int</span> ((<span class="ot">-&gt;</span>) <span class="dt">Int</span> <span class="dt">Int</span>)

<span class="kw">type</span> <span class="dt">IntTuple</span> <span class="fu">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="kw">type</span> <span class="dt">IntTuple</span> <span class="fu">=</span> (,) <span class="dt">Int</span> <span class="dt">Int</span></code></pre>
</section>
<section id="types-and-constructors-1" class="slide level1 small-title big-code highlight-type">
<h1></h1>
<h1>
<span class="hl-type">Types</span> and <span class="hl-constructor">Constructors</span>
</h1>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt hl-type">Choice</span> <span class="fu">=</span> <span class="dt hl-constructor">Definitely</span>
            <span class="fu">|</span> <span class="dt hl-constructor">Possibly</span>
            <span class="fu">|</span> <span class="dt hl-constructor">NoWay</span>

<span class="kw">data</span> <span class="dt hl-type">Choices</span> <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> <span class="dt hl-type">Choice</span> <span class="dt hl-type">Choice</span>

<span class="ot">mkChoices ::</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choices</span>
mkChoices a b <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> a b

<span class="ot">fstChoice ::</span> <span class="dt hl-type">Choices</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span>
fstChoice (<span class="dt hl-constructor">Choices</span> a _) <span class="fu">=</span> a</code></pre>

</section>
<section id="types-and-constructors-2" class="slide level1 small-title big-code highlight-constructor">
<h1></h1>
<h1>
<span class="hl-type">Types</span> and <span class="hl-constructor">Constructors</span>
</h1>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt hl-type">Choice</span> <span class="fu">=</span> <span class="dt hl-constructor">Definitely</span>
            <span class="fu">|</span> <span class="dt hl-constructor">Possibly</span>
            <span class="fu">|</span> <span class="dt hl-constructor">NoWay</span>

<span class="kw">data</span> <span class="dt hl-type">Choices</span> <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> <span class="dt hl-type">Choice</span> <span class="dt hl-type">Choice</span>

<span class="ot">mkChoices ::</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choices</span>
mkChoices a b <span class="fu">=</span> <span class="dt hl-constructor">Choices</span> a b

<span class="ot">fstChoice ::</span> <span class="dt hl-type">Choices</span> <span class="ot">-&gt;</span> <span class="dt hl-type">Choice</span>
fstChoice (<span class="dt hl-constructor">Choices</span> a _) <span class="fu">=</span> a</code></pre>

</section>
<section id="using-types" class="slide level1 big-code">
<h1>Using Types</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Terms can be annotated in-line</span>
<span class="dv">2</span> <span class="fu">^</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)

<span class="co">-- Bindings can be annotated</span>
<span class="ot">success ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="co">-- Constructors are terms</span>
<span class="co">-- (and product constructors are functions)</span>
success x <span class="fu">=</span> <span class="dt">Just</span> x

<span class="co">-- Constructors can be pattern matched</span>
<span class="co">-- _ is a wildcard</span>
<span class="kw">case</span> success <span class="dt">True</span> <span class="kw">of</span>
  <span class="dt">Just</span> <span class="dt">True</span> <span class="ot">-&gt;</span> ()
  _         <span class="ot">-&gt;</span> ()</code></pre>
</section>
<section id="ghci" class="slide level1">
<h1>GHCi</h1>
<h2>
Interactive Haskell
</h2>

</section>
<section id="runhaskell" class="slide level1 medium-code">
<h1></h1>
<pre class="sourceCode bash"><code class="sourceCode bash">
$ <span class="kw">runhaskell</span> --help
<span class="kw">Usage</span>: runghc [runghc flags] [GHC flags] module [program args]

<span class="kw">The</span> runghc flags are
    <span class="kw">-f</span> /path/to/ghc       Tell runghc where GHC is
    <span class="kw">--help</span>                Print this usage information
    <span class="kw">--version</span>             Print version number</code></pre>
</section>
<section id="ghci-start" class="slide level1 medium-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="fu">$</span> ghci
<span class="dt">GHCi</span>, version <span class="dv">7</span><span class="fu">.</span><span class="dv">8</span><span class="fu">.</span><span class="dv">2</span><span class="fu">:</span> http<span class="fu">://</span>www<span class="fu">.</span>haskell<span class="fu">.</span>org<span class="fu">/</span>ghc<span class="fu">/</span>  <span class="fu">:?</span> for help
<span class="dt">Loading</span> package ghc<span class="fu">-</span>prim <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="dt">Loading</span> package integer<span class="fu">-</span>gmp <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
<span class="dt">Loading</span> package base <span class="fu">...</span> linking <span class="fu">...</span> done<span class="fu">.</span>
h<span class="fu">&gt;</span> </code></pre>
</section>
<section id="ghci-t" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:t</code> shows type information
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>t map
map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
h<span class="fu">&gt;</span> <span class="fu">:</span>t map (<span class="fu">+</span><span class="dv">1</span>)
map (<span class="fu">+</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> [b] <span class="ot">-&gt;</span> [b]
h<span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">&gt;&gt;=</span>)
<span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre>
</section>
<section id="ghci-i-typeclass" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:i</code> shows typeclass info
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Num</span>
<span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span>
<span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">  abs ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">  signum ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">  fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a
    <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Integer</span> <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Float</span> <span class="co">-- Defined in `GHC.Float&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Double</span> <span class="co">-- Defined in `GHC.Float&#39;</span></code></pre>
</section>
<section id="ghci-i-value" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:i</code> shows term info
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>info map
map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]   
<span class="co">-- Defined in `GHC.Base&#39;</span>
h<span class="fu">&gt;</span> <span class="fu">:</span>info (<span class="fu">&gt;&gt;=</span>)
<span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
  <span class="fu">...</span>
    <span class="co">-- Defined in `GHC.Base&#39;</span>
<span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&gt;&gt;=</span></code></pre>
</section>
<section id="ghci-i-type" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:i</code> shows type info
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> ghc<span class="fu">-</span>prim<span class="fu">:</span><span class="dt">GHC.Types.I</span><span class="st">#</span>
  ghc<span class="fu">-</span>prim<span class="fu">:</span><span class="dt">GHC.Prim.Int</span><span class="st">#</span>
  <span class="co">-- Defined in `ghc-prim:GHC.Types&#39;</span>
<span class="kw">instance</span> <span class="dt">Bounded</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Enum&#39;</span>
<span class="kw">instance</span> <span class="dt">Enum</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Enum&#39;</span>
<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Classes&#39;</span>
<span class="kw">instance</span> <span class="dt">Integral</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Real&#39;</span>
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Num&#39;</span>
<span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Classes&#39;</span>
<span class="kw">instance</span> <span class="dt">Read</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Read&#39;</span>
<span class="kw">instance</span> <span class="dt">Real</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Real&#39;</span>
<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Show&#39;</span></code></pre>
</section>
<section id="ghci-load-reload" class="slide level1 big-code">
<h1></h1>
<h2>
<code>:l</code> load a module
</h2>
<h2>
<code>:r</code> to reload
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="fu">:!</span> echo <span class="ch">&#39;hello = print &quot;hello&quot;&#39;</span> <span class="fu">&gt;</span> Hello.hs
h<span class="fu">&gt;</span> <span class="fu">:</span>l <span class="dt">Hello</span>
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( Hello.hs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Main</span><span class="fu">.</span>
h<span class="fu">&gt;</span> hello
<span class="st">&quot;hello&quot;</span>
h<span class="fu">&gt;</span> <span class="fu">:!</span> echo <span class="ch">&#39;hello = print &quot;HELLO&quot;&#39;</span> <span class="fu">&gt;</span> Hello.hs
h<span class="fu">&gt;</span> <span class="fu">:</span>r
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span> ( Hello.hs, interpreted )
<span class="dt">Ok</span>, modules loaded<span class="fu">:</span> <span class="dt">Main</span><span class="fu">.</span>
h<span class="fu">&gt;</span> hello
<span class="st">&quot;HELLO&quot;</span></code></pre>
</section>
<section id="map" class="slide level1 big-code">
<h1>map</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map _ []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre>
</section>
<section id="foldr" class="slide level1 big-code">
<h1>foldr</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldr k z <span class="fu">=</span> go
   <span class="kw">where</span>
     go []     <span class="fu">=</span> z
     go (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="ot">`k`</span> go ys</code></pre>
</section>
<section id="pattern-matching" class="slide level1 big-code">
<h1>Pattern Matching</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isJust (<span class="dt">Just</span> _) <span class="fu">=</span> <span class="dt">True</span>
isJust <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">False</span></code></pre>
</section>
<section id="pattern-matching-1" class="slide level1 big-code">
<h1>Pattern Matching</h1>
<p>Haskell only implements linear patterns</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- DOES NOT WORK!</span>
<span class="ot">isEqual ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isEqual a a <span class="fu">=</span> <span class="dt">True</span>
isEqual _ _ <span class="fu">=</span> <span class="dt">False</span></code></pre>
<blockquote>
This isn't even possible! Only constructors can be pattern matched. Types have no built-in equality.
</blockquote>

</section>
<section id="infix-and-prefix" class="slide level1 big-code">
<h1>`Infix` and (Prefix)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Symbolic operators can be used</span>
<span class="co">-- prefix when in (parentheses)</span>
(<span class="fu">+</span>) a b

<span class="co">-- Named functions can be used</span>
<span class="co">-- infix when in `backticks`</span>
x <span class="ot">`elem`</span> xs

<span class="co">-- infixl, infixr define associativity</span>
<span class="co">-- and precedence (0 lowest, 9 highest)</span>
<span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">`append`</span>
a <span class="ot">`append`</span> b <span class="fu">=</span> a <span class="fu">++</span> b</code></pre>
</section>
<section id="functions-lambdas" class="slide level1 big-code">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc x <span class="fu">=</span> acc <span class="fu">+</span> x

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun xs <span class="fu">=</span> foldl add <span class="dv">0</span> xs

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda xs <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu">+</span> x) <span class="dv">0</span> xs</code></pre>
</section>
<section id="functions-lambdas-1" class="slide level1 big-code">
<h1>Functions &amp; Lambdas</h1>
<ul>
<li>Haskell <em>only</em> has functions of one argument</li>
<li><code>a -&gt; b -&gt; c</code> is really <code>a -&gt; (b -&gt; c)</code></li>
<li><code>f a b</code> is really <code>(f a) b</code></li>
<li>Let's leverage that…</li>
</ul>
</section>
<section id="functions-lambdas-2" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc x <span class="fu">=</span> acc <span class="fu">+</span> x

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="hl">xs</span> <span class="fu">=</span> foldl add <span class="dv">0</span> <span class="hl">xs</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="hl">xs</span> <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu">+</span> x) <span class="dv">0</span> <span class="hl">xs</span></code></pre>

</section>
<section id="functions-lambdas-3" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc x <span class="fu">=</span> acc <span class="fu hl">+</span> x

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl (\acc x <span class="ot">-&gt;</span> acc <span class="fu hl">+</span> x) <span class="dv">0</span></code></pre>

</section>
<section id="functions-lambdas-4" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add acc <span class="hl">x</span> <span class="fu">=</span> <span class="fu">(+)</span> acc <span class="hl">x</span>

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl (\acc <span class="hl">x</span> <span class="ot">-&gt;</span> <span class="fu">(+)</span> acc <span class="hl">x</span>) <span class="dv">0</span></code></pre>

</section>
<section id="functions-lambdas-5" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add <span class="hl">acc</span> <span class="fu">=</span> <span class="fu">(+)</span> <span class="hl">acc</span>

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl (\<span class="hl">acc</span> <span class="ot">-&gt;</span> <span class="fu">(+)</span> <span class="hl">acc</span>) <span class="dv">0</span></code></pre>

</section>
<section id="functions-lambdas-6" class="slide level1 big-code highlight">
<h1>Functions &amp; Lambdas</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add <span class="fu">=</span> <span class="fu">(+)</span>

<span class="ot">sumFun ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumFun <span class="fu">=</span> foldl add <span class="dv">0</span>

<span class="ot">sumLambda ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumLambda <span class="fu">=</span> foldl <span class="fu">(+)</span> <span class="dv">0</span></code></pre>

</section>
<section id="guards" class="slide level1 big-code">
<h1>Guards</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isNegative ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isNegative x
  <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="dt">True</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span></code></pre>
</section>
<section id="guards-1" class="slide level1 big-code">
<h1>Guards</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isNegative ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isNegative x
  <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="dt">True</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span>

<span class="ot">absoluteValue ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
absoluteValue x
  <span class="fu">|</span> isNegative x <span class="fu">=</span> <span class="fu">-</span>x
  <span class="fu">|</span> otherwise    <span class="fu">=</span> x</code></pre>
</section>
<section id="built-in-types" class="slide level1 big-code small-title">
<h1>Built-in types</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- (), pronounced &quot;unit&quot;</span>
<span class="ot">unit ::</span> ()
unit <span class="fu">=</span> ()

<span class="co">-- Char</span>
<span class="ot">someChar ::</span> <span class="dt">Char</span>
someChar <span class="fu">=</span> <span class="ch">&#39;x&#39;</span>

<span class="co">-- Instances of Num typeclass</span>
<span class="ot">someDouble ::</span> <span class="dt">Double</span>
someDouble <span class="fu">=</span> <span class="dv">1</span>

<span class="co">-- Instances of Fractional typeclass</span>
<span class="ot">someRatio ::</span> <span class="dt">Rational</span>
someRatio <span class="fu">=</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">2345</span></code></pre>
</section>
<section id="lists-tuples" class="slide level1 big-code small-title">
<h1>Lists &amp; Tuples</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- [a], type can be written prefix as `[] a`</span>
someList,<span class="ot"> someOtherList ::</span> [<span class="dt">Int</span>]
someList <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
someOtherList <span class="fu">=</span> <span class="dv">4</span> <span class="fu">:</span> <span class="dv">5</span> <span class="fu">:</span> <span class="dv">6</span> <span class="fu">:</span> []
dontWriteThis <span class="fu">=</span> (<span class="fu">:</span>) <span class="dv">4</span> (<span class="dv">5</span> <span class="fu">:</span> (<span class="fu">:</span>) <span class="dv">6</span> [])

<span class="co">-- (a, b), can be written prefix as `(,) a b`</span>
someTuple,<span class="ot"> someOtherTuple ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
someTuple <span class="fu">=</span> (<span class="dv">10</span>, <span class="ch">&#39;4&#39;</span>)
someOtherTuple <span class="fu">=</span> (,) <span class="dv">4</span> <span class="ch">&#39;2&#39;</span>

<span class="co">-- [Char], also known as String</span>
<span class="co">-- (also see the OverloadedStrings extension)</span>
<span class="ot">someString ::</span> <span class="dt">String</span>
someString <span class="fu">=</span> <span class="st">&quot;foo&quot;</span></code></pre>
</section>
<section id="typeclass-syntax" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Equals</span> a <span class="kw">where</span>
<span class="ot">  isEqual ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">Equals</span> <span class="dt">Choice</span> <span class="kw">where</span>
  isEqual <span class="dt">Definitely</span> <span class="dt">Definitely</span> <span class="fu">=</span> <span class="dt">True</span>
  isEqual <span class="dt">Possibly</span>   <span class="dt">Possibly</span>   <span class="fu">=</span> <span class="dt">True</span>
  isEqual <span class="dt">NoWay</span>      <span class="dt">NoWay</span>      <span class="fu">=</span> <span class="dt">True</span>
  isEqual _          _          <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> (<span class="dt">Equals</span> a) <span class="ot">=&gt;</span> <span class="dt">Equals</span> [a] <span class="kw">where</span>
  isEqual (a<span class="fu">:</span>as) (b<span class="fu">:</span>bs) <span class="fu">=</span> isEqual a b <span class="fu">&amp;&amp;</span>
                          isEqual as bs
  isEqual as     bs     <span class="fu">=</span> null as <span class="fu">&amp;&amp;</span> null bs</code></pre>
</section>
<section id="typeclass-syntax-1" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-</span>
<span class="co">class Eq a where</span>
<span class="co">  (==) :: a -&gt; a -&gt; Bool</span>
<span class="co">-}</span>

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Choice</span> <span class="kw">where</span>
  <span class="dt">Definitely</span> <span class="fu">==</span> <span class="dt">Definitely</span> <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">Possibly</span>   <span class="fu">==</span> <span class="dt">Possibly</span>   <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">NoWay</span>      <span class="fu">==</span> <span class="dt">NoWay</span>      <span class="fu">=</span> <span class="dt">True</span>
  _          <span class="fu">==</span> _          <span class="fu">=</span> <span class="dt">False</span></code></pre>
</section>
<section id="typeclass-syntax-2" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Definitely</span>
            <span class="fu">|</span> <span class="dt">Possibly</span>
            <span class="fu">|</span> <span class="dt">NoWay</span>
            <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre>
</section>
<section id="typeclass-syntax-3" class="slide level1 big-code">
<h1>Typeclass Syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Definitely</span>
            <span class="fu">|</span> <span class="dt">Possibly</span>
            <span class="fu">|</span> <span class="dt">NoWay</span>
            <span class="kw">deriving</span> ( <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>
                     , <span class="dt">Show</span>, <span class="dt">Read</span> )</code></pre>
</section>
<section id="quickcheck" class="slide level1 big-code">
<h1>QuickCheck</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_intIdentity ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_intIdentity i <span class="fu">=</span> i <span class="fu">==</span> i</code></pre>
</section>
<section id="quickcheck-1" class="slide level1 big-code">
<h1>QuickCheck</h1>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghci</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
λ&gt; quickCheck (\i <span class="ot">-&gt;</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="fu">==</span> i)
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre>
</section>
<section id="quickcheck-isnt-magic" class="slide level1 big-code small-title">
<h1>QuickCheck Isn't Magic</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
λ&gt; quickCheck (\i <span class="ot">-&gt;</span> (<span class="ot">i ::</span> <span class="dt">Double</span>) <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> i)
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre>
</section>
<section id="quickcheck-isnt-magic-1" class="slide level1 big-code small-title">
<h1>QuickCheck Isn't Magic</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
λ&gt; quickCheck (\i <span class="ot">-&gt;</span> (<span class="ot">i ::</span> <span class="dt">Double</span>) <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> i)
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span>
λ&gt; <span class="kw">let</span> i <span class="fu">=</span> <span class="dv">0</span><span class="fu">/</span><span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span> <span class="kw">in</span> i <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> i
<span class="dt">False</span></code></pre>
</section>
<section id="quickcheck-isnt-magic-2" class="slide level1 big-code small-title">
<h1>QuickCheck Isn't Magic</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">import </span><span class="dt">Test.QuickCheck</span>
λ&gt; quickCheck (\i <span class="ot">-&gt;</span> (<span class="ot">i ::</span> <span class="dt">Double</span>) <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> i)
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span>
λ&gt; <span class="kw">let</span> i <span class="fu">=</span> <span class="dv">0</span><span class="fu">/</span><span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span> <span class="kw">in</span> i <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> i
<span class="dt">False</span>
λ&gt; <span class="kw">let</span> i <span class="fu">=</span> 1<span class="ot">e16 ::</span> <span class="dt">Double</span> <span class="kw">in</span> i <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> i
<span class="dt">False</span></code></pre>
</section>
<section id="do-syntax-io" class="slide level1 big-code">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  secret <span class="ot">&lt;-</span> readFile <span class="st">&quot;/etc/passwd&quot;</span>
  writeFile <span class="st">&quot;/tmp/passwd&quot;</span> secret
  return ()</code></pre>
</section>
<section id="do-syntax" class="slide level1 big-code">
<h1>Do syntax</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">do</span> m
<span class="co">-- desugars to:</span>
m

<span class="kw">do</span> a <span class="ot">&lt;-</span> m
   return a
<span class="co">-- desugars to:</span>
m <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> return a

<span class="kw">do</span> m
   return ()
<span class="co">-- desugars to:</span>
m <span class="fu">&gt;&gt;</span> return ()</code></pre>
</section>
<section id="do-syntax-io-1" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="hl"><span class="kw">do</span></span>
  <span class="hl">secret <span class="ot">&lt;-</span></span> readFile <span class="st">"/etc/passwd"</span>
  writeFile <span class="st">"/tmp/passwd"</span> secret
  return ()</code></pre>

</section>
<section id="do-syntax-io-2" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="hl">&gt;&gt;= \secret -> do</span>
  writeFile <span class="st">"/tmp/passwd"</span> secret
  return ()</code></pre>

</section>
<section id="do-syntax-io-3" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="fu">&gt;&gt;=</span> \secret <span class="ot">-></span>
  writeFile <span class="st">"/tmp/passwd"</span> secret <span class="hl">&gt;&gt;</span>
  return ()</code></pre>

</section>
<section id="do-syntax-io-4" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="fu">&gt;&gt;=</span><span class="hl"> \secret <span class="ot">-></span></span>
  writeFile <span class="st">"/tmp/passwd"</span> <span class="hl">secret</span></code></pre>

</section>
<section id="do-syntax-io-5" class="slide level1 big-code highlight">
<h1>Do syntax (IO)</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  readFile <span class="st">"/etc/passwd"</span> <span class="fu">&gt;&gt;=</span>
  writeFile <span class="st">"/tmp/passwd"</span></code></pre>

</section>
<section id="do-syntax-a" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> [ y <span class="fu">|</span> x <span class="ot">&lt;-</span> xs, y <span class="ot">&lt;-</span> f x ]</code></pre>
</section>
<section id="do-syntax-a-1" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> xs
  y <span class="ot">&lt;-</span> f x
  return y</code></pre>
</section>
<section id="do-syntax-a-2" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> xs
  f x</code></pre>
</section>
<section id="do-syntax-a-3" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> xs <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> f x</code></pre>
</section>
<section id="do-syntax-a-4" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> xs <span class="fu">&gt;&gt;=</span> f</code></pre>
</section>
<section id="do-syntax-a-5" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap f xs <span class="fu">=</span> flip (<span class="fu">&gt;&gt;=</span>) f xs</code></pre>
</section>
<section id="do-syntax-a-6" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap <span class="fu">=</span> flip (<span class="fu">&gt;&gt;=</span>)</code></pre>
</section>
<section id="do-syntax-a-7" class="slide level1 big-code">
<h1>Do syntax ([a])</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
flatMap <span class="fu">=</span> (<span class="fu">=&lt;&lt;</span>)</code></pre>
</section>
<section id="side-effects" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- WordCount1.hs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  input <span class="ot">&lt;-</span> getContents
  <span class="kw">let</span> wordCount <span class="fu">=</span> length (words input)
  print wordCount</code></pre>
</section>
<section id="side-effects-2" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- WordCount2.hs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  getContents <span class="fu">&gt;&gt;=</span> \input <span class="ot">-&gt;</span>
    <span class="kw">let</span> wordCount <span class="fu">=</span> length (words input)
    <span class="kw">in</span> print wordCount</code></pre>
</section>
<section id="side-effects-3" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- WordCount3.hs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> getContents <span class="fu">&gt;&gt;=</span> print <span class="fu">.</span> length <span class="fu">.</span> words</code></pre>
</section>
<section id="what.the" class="slide level1">
<h1>what.the <code>&gt;&gt;=</code>?</h1>
<ul>
<li><code>do</code> is just syntax sugar for the <code>&gt;&gt;=</code> (bind) operator.</li>
<li>IO is still purely functional, we are just building a graph of actions, <em>not</em> executing them in-place!</li>
<li>Starting from <code>main</code>, the Haskell runtime will <em>evaluate</em> these actions</li>
<li>It works much like continuation passing style, with a state variable for the current world state (behind the scenes)</li>
<li>There are ways to cheat and write code that is not pure, but you will have to go out of your way to do it</li>
</ul>
</section>
<section id="common-combinators" class="slide level1 big-code">
<h1>Common combinators</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Function composition</span>
<span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
f <span class="fu">.</span> g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)

<span class="co">-- Function application (with a lower precedence)</span>
<span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">$</span> x <span class="fu">=</span>  f x</code></pre>
</section>
<section id="pure" class="slide level1">
<h1>Pure</h1>
<ul>
<li>Haskell's purity implies referential transparency</li>
<li>This means that function invocation can be freely replaced with its return value without changing semantics</li>
<li>Fantastic for optimizations</li>
<li>Also enables equational reasoning, which makes it easier to prove code correct</li>
</ul>
</section>
<section id="compiler" class="slide level1">
<h1></h1>
<!--
https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
-->
<svg viewBox="0 0 1000 1000" class="full diagram">
  
<defs> <marker id="Triangle"
      viewBox="0 0 10 10" refX="0" refY="5" 
      markerUnits="strokeWidth"
      markerWidth="4" markerHeight="3"
      orient="auto"> <path d="M 0 0 L 10 5 L 0 10 z" /> </marker> </defs> <g class="right-title" transform="translate(1000, 20)"> <text>GHC compilation phases</text> </g> <g class="phase parse" transform="translate(500, 85)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Parse</text> </g> <g class="phase rename" transform="translate(500, 215)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Rename</text> </g> <g class="phase typecheck" transform="translate(500, 345)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Typecheck</text> </g> <g class="phase desugar" transform="translate(500, 475)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Desugar</text> </g> <g class="phase optimize" transform="translate(500, 605)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <path d="M 65,35 a 160,80 0 1,0 40,-80" marker-end="url(#Triangle)"/> <text x="220" class="outside">Core</text> <ellipse rx="120" ry="35"/> <text>Optimize</text> </g> <g class="phase codegen" transform="translate(500, 735)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>Code gen</text> </g> <g class="phase llvm" transform="translate(500, 865)"> <line y1="-85" y2="-65" marker-end="url(#Triangle)" /> <ellipse rx="120" ry="35"/> <text>LLVM</text> <line y1="45" y2="65" marker-end="url(#Triangle)" /> </g>
</svg>

</section>
<section id="optimizations" class="slide level1">
<h1>Optimizations</h1>
<!--
http://stackoverflow.com/questions/12653787/what-optimizations-can-ghc-be-expected-to-perform-reliably 
http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
-->

<ul>
<li>Common sub-expression elimination</li>
<li>Inlining (cross-module too!)</li>
<li>Specialize</li>
<li>Float out</li>
<li>Float inwards</li>
<li>Demand analysis</li>
<li>Worker/Wrapper binds</li>
<li>Liberate case</li>
<li>Call-pattern specialization (SpecConstr)</li>
</ul>
</section>
<section id="ghc-rules" class="slide level1">
<h1>GHC RULES!</h1>
<!--
http://www.haskell.org/haskellwiki/Playing_by_the_rules
http://www.haskell.org/haskellwiki/GHC/Using_rules
https://ghc.haskell.org/trac/ghc/wiki/RewriteRules
-->

<ul>
<li>Term rewriting engine</li>
<li>RULES pragma allows <em>library defined optimizations</em></li>
<li>Used to great effect for short cut fusion</li>
<li>Example: <code>map f (map g xs) = map (f . g) xs</code></li>
<li>Prevent building of intermediate data structures</li>
<li>Commonly used for lists, Text, ByteString, etc.</li>
<li>Great incentive to write high-level code!</li>
<li>ANY LIBRARY CAN USE THIS!</li>
</ul>
</section>
<section id="ghc-rules-ex" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">{-# RULES</span>
<span class="co">&quot;ByteString specialise break (x==)&quot; forall x.</span>
<span class="co">    break ((==) x) = breakByte x</span>
<span class="co">&quot;ByteString specialise break (==x)&quot; forall x.</span>
<span class="co">    break (==x) = breakByte x</span>
<span class="co">  #-}</span></code></pre>
</section>
<section id="ghc-rules-1" class="slide level1 big-code">
<h1>GHC RULES</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">{-# RULES</span>
<span class="co">&quot;ByteString specialise break (x==)&quot; forall x.</span>
<span class="co">    break ((==) x) = breakByte x</span>
<span class="co">&quot;ByteString specialise break (==x)&quot; forall x.</span>
<span class="co">    break (==x) = breakByte x</span>
<span class="co">  #-}</span>

<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>, break)

<span class="ot">splitLine ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">ByteString</span>, <span class="dt">ByteString</span>)
splitLine <span class="fu">=</span> break (<span class="fu">==</span><span class="ch">&#39;\n&#39;</span>)</code></pre>
</section>
<section id="ghc-rules-2" class="slide level1 big-code">
<h1>GHC RULES</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">{-# RULES</span>
<span class="co">&quot;ByteString specialise break (x==)&quot; forall x.</span>
<span class="co">    break ((==) x) = breakByte x</span>
<span class="co">&quot;ByteString specialise break (==x)&quot; forall x.</span>
<span class="co">    break (==x) = breakByte x</span>
<span class="co">  #-}</span>

<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>, break)

<span class="ot">splitLine ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">ByteString</span>, <span class="dt">ByteString</span>)
splitLine <span class="fu">=</span> breakByte <span class="ch">&#39;\n&#39;</span></code></pre>
</section>
<section id="lazy" class="slide level1">
<h1>Lazy</h1>
<ul>
<li>Call by need (outside in), not call by value (inside out)</li>
<li>Non-strict evaluation separates equation from execution</li>
<li>No need for special forms for control flow, no value restriction</li>
<li>Enables infinite or cyclic data structures</li>
<li>Can skip unused computation (better minimum bounds)</li>
</ul>
</section>
<section id="lazy-ramsey" class="slide level1">
<h1></h1>
<figure>
<img src="img/ramsey-lazy-2013.jpg" alt="lazy" /><figcaption>lazy</figcaption>
</figure>
</section>
<section id="call-by-need" class="slide level1">
<h1>Call by need</h1>
<!--
https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
http://research.microsoft.com/apps/pubs/default.aspx?id=67083
-->

<ul>
<li>Expressions are translated into a graph (not a tree!)</li>
<li>Evaluated with STG (Spineless Tagless G-Machine)</li>
<li>Pattern matching forces evaluation</li>
</ul>
</section>
<section id="non-strict-evaluation" class="slide level1 big-code">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- [1..] is an infinite list, [1, 2, 3, ...]</span>
print (head (map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">..</span>]))</code></pre>
</section>
<section id="non-strict-evaluation-1" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- [1..] is an infinite list, [1, 2, 3, ...]</span>
<span class="hl">print (</span>head (map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">..</span>])<span class="hl">)</span>
<span class="co">-- Outside in, print x = putStrLn (show x)</span>
<span class="hl">putStrLn (show (</span>head (map (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">..</span>]<span class="hl">))</span></code></pre>

</section>
<section id="non-strict-evaluation-2" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Outside in, print x = putStrLn (show x)</span>
putStrLn (show (<span class="hl2">head (<span class="hl1">map (<span class="fu">*</span><span class="dv">2</span>) <span class="hl">[<span class="dv">1</span><span class="fu">..</span>]</span>)</span>)</span>
<span class="co">-- head (x:_) = x</span>
<span class="co">-- map f (x:xs) = f x : map f xs</span>
<span class="co">-- desugar [1..] syntax</span>
putStrLn (show (head (map (<span class="fu">*</span><span class="dv">2</span>) (<span class="hl">enumFrom <span class="dv">1</span></span>))))</code></pre>

</section>
<section id="non-strict-evaluation-3" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- desugar [1..] syntax</span>
putStrLn (show (head (map (<span class="fu">*</span><span class="dv">2</span>) (<span class="hl">enumFrom <span class="dv">1</span></span>))))
<span class="co">-- enumFrom n = n : enumFrom (succ n)</span>
putStrLn (show (head (map (<span class="fu">*</span><span class="dv">2</span>)
                          (<span class="hl"><span class="dv">1</span> <span class="fu">:</span> enumFrom (succ <span class="dv">1</span>)</span>))))</code></pre>

</section>
<section id="non-strict-evaluation-4" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- enumFrom n = n : enumFrom (succ n)</span>
putStrLn (show (head (<span class="hl1">map (<span class="fu">*</span><span class="dv">2</span>)</span>
                          <span class="hl1">(<span class="hl"><span class="dv">1</span> <span class="fu">:</span></span> enumFrom (succ <span class="dv">1</span>))</span>)))
<span class="co">-- apply map</span>
putStrLn (show (head
                  (<span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>) <span class="fu">:</span></span>
                   <span class="hl1">map (<span class="fu">*</span><span class="dv">2</span>) (enumFrom (succ <span class="dv">1</span>))</span>)))</code></pre>

</section>
<section id="non-strict-evaluation-5" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- apply map</span>
putStrLn (show (<span class="hl1">head (<span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)</span> <span class="fu">:</span> …)</span>))
<span class="co">-- apply head</span>
putStrLn (show <span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)</span>)</code></pre>

</section>
<section id="non-strict-evaluation-6" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- apply head</span>
putStrLn (show <span class="hl">(<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)</span>)
<span class="co">-- show pattern matches on its argument</span>
putStrLn (show <span class="hl"><span class="dv">2</span></span>)</code></pre>

</section>
<section id="non-strict-evaluation-7" class="slide level1 big-code highlight">
<h1>Non-Strict Evaluation</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- show pattern matches on its argument</span>
putStrLn (<span class="hl">show <span class="dv">2</span></span>)
<span class="co">-- apply show</span>
putStrLn <span class="hl"><span class="st">"2"</span></span></code></pre>

</section>
<section id="control-flow" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">if&#39; ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
if&#39; cond a b <span class="fu">=</span> <span class="kw">case</span> cond <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> a
  <span class="dt">False</span> <span class="ot">-&gt;</span> b

<span class="ot">(&amp;&amp;) ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
a <span class="fu">&amp;&amp;</span> b <span class="fu">=</span> <span class="kw">case</span> a <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> b
  <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">False</span>

const<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
const x <span class="fu">=</span> \_ <span class="ot">-&gt;</span> x</code></pre>
</section>
<section id="infinite-programming" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">fib ::</span> [<span class="dt">Integer</span>]
fib <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fib (tail fib)

cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]
cycle xs <span class="fu">=</span> xs <span class="fu">++</span> cycle xs

iterate<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
iterate f x <span class="fu">=</span> x <span class="fu">:</span> iterate f (f x)

takeWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
takeWhile _ [] <span class="fu">=</span> []
takeWhile p (x<span class="fu">:</span>xs)
  <span class="fu">|</span> p x       <span class="fu">=</span> x <span class="fu">:</span> takeWhile p xs
  <span class="fu">|</span> otherwise <span class="fu">=</span> []</code></pre>
</section>
<section id="types-1" class="slide level1">
<h1>Types</h1>
<ul>
<li>Enforce constraints at compile time</li>
<li>No NULL</li>
<li>Can have parametric polymorphism and/or recursion</li>
<li>Built-in types are not special (other than syntax)</li>
<li>Typeclasses for <em>ad hoc</em> polymorphism (overloading)</li>
</ul>
</section>
<section id="constraints" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="kw">let</span> f x <span class="fu">=</span> head <span class="dt">True</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">23</span><span class="fu">:</span><span class="dv">16</span><span class="fu">:</span>
    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> <span class="ot">`[a0]&#39; with actual type `</span><span class="dt">Bool&#39;</span>
    <span class="dt">In</span> the first argument <span class="kw">of</span> <span class="ot">`head&#39;, namely `</span><span class="dt">True&#39;</span>
    <span class="dt">In</span> the expression<span class="fu">:</span> head <span class="dt">True</span>
    <span class="dt">In</span> an equation for <span class="ot">`f&#39;: f x = head True</span>

<span class="ot">h&gt; let f x = heads True</span>

<span class="ot">&lt;interactive&gt;:24:11:</span>
<span class="ot">    Not in scope: `</span>heads&#39;
    <span class="dt">Perhaps</span> you meant one <span class="kw">of</span> these<span class="fu">:</span>
      <span class="ot">`reads&#39; (imported from Prelude), `</span>head&#39; (imported from <span class="dt">Prelude</span>)</code></pre>
</section>
<section id="bottoms" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
h<span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> x <span class="kw">in</span> x
<span class="co">-- Infinite recursion, not a fun case to deal with!</span>

h<span class="fu">&gt;</span> <span class="kw">case</span> <span class="dt">False</span> <span class="kw">of</span> <span class="dt">True</span> <span class="ot">-&gt;</span> ()
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">29</span><span class="fu">:</span><span class="dv">1</span><span class="fu">-</span><span class="dv">24</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> <span class="kw">case</span>

h<span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list

h<span class="fu">&gt;</span> error <span class="st">&quot;this throws an exception&quot;</span>
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> this throws an exception

h<span class="fu">&gt;</span> undefined
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre>
</section>
<section id="polymorphic" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Polymorphic and recursive</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>
            <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a
            <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)
            <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">listMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
listMap _ <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">Nil</span>
listMap f (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) (listMap f xs)

<span class="ot">treeToList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
treeToList root <span class="fu">=</span> go root <span class="dt">Nil</span>
  <span class="kw">where</span>
    <span class="co">-- Note that `go` returns a function!</span>
    go (<span class="dt">Leaf</span> x)     <span class="fu">=</span> <span class="dt">Cons</span> x
    go (<span class="dt">Branch</span> l r) <span class="fu">=</span> go l <span class="fu">.</span> go r</code></pre>
</section>
<section id="typeclasses" class="slide level1">
<h1>Typeclasses</h1>
<ul>
<li>Used for many of the Prelude operators and numeric literals</li>
<li>Ad hoc polymorphism (overloading)</li>
<li>Many built-in typeclasses can be automatically derived (Eq, Ord, Enum, Bounded, Show, and Read)!</li>
</ul>
</section>
<section id="typeclass-example" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">module</span> <span class="dt">List</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>

<span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  (<span class="dt">Cons</span> a as) <span class="fu">==</span> (<span class="dt">Cons</span> b bs) <span class="fu">=</span> a <span class="fu">==</span> b <span class="fu">&amp;&amp;</span> as <span class="fu">==</span> bs
  <span class="dt">Nil</span>         <span class="fu">==</span> <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">True</span>
  _           <span class="fu">==</span> _           <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span>
  fmap _ <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">Nil</span>
  fmap f (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) (fmap f xs)</code></pre>
</section>
<section id="typeclass-example-2" class="slide level1 big-code">
<h1></h1>
<!-- http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>

<span class="kw">module</span> <span class="dt">List</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
            <span class="fu">|</span> <span class="dt">Nil</span>
            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>)</code></pre>
</section>
<section id="newtype" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">import </span><span class="dt">Data.List</span> (sort)

<span class="kw">newtype</span> <span class="dt">Down</span> a <span class="fu">=</span> <span class="dt">Down</span> {<span class="ot"> unDown ::</span> a }
                 <span class="kw">deriving</span> (<span class="dt">Eq</span>)

<span class="kw">instance</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">Down</span> a) <span class="kw">where</span>
  compare (<span class="dt">Down</span> a) (<span class="dt">Down</span> b) <span class="fu">=</span> <span class="kw">case</span> compare a b <span class="kw">of</span>
    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">GT</span>
    <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">EQ</span>
    <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">LT</span>

<span class="ot">reverseSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
reverseSort <span class="fu">=</span> map unDown <span class="fu">.</span> sort <span class="fu">.</span> map <span class="dt">Down</span></code></pre>
</section>
<section id="abstractions" class="slide level1">
<h1>Abstractions</h1>
<dl>
<dt>Monoid</dt>
<dd>Has an identity and an associative operation
</dd>
<dt>Functor</dt>
<dd>Anything that can be mapped over (preserving structure)
</dd>
<dt>Applicative</dt>
<dd>Functor, but can apply function from inside
</dd>
<dt>Monad</dt>
<dd>Applicative, but can return any structure
</dd>
</dl>
</section>
<section id="monoid" class="slide level1">
<h1>Monoid</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">  mempty ::</span> a
<span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span>
  mempty <span class="fu">=</span> []
  mappend <span class="fu">=</span> (<span class="fu">++</span>)

<span class="kw">infixr</span> <span class="dv">6</span> <span class="fu">&lt;&gt;</span>
<span class="ot">(&lt;&gt;) ::</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
(<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> mappend</code></pre>
</section>
<section id="functor" class="slide level1">
<h1>Functor</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  fmap <span class="fu">=</span> map

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)
  fmap _ <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;$&gt;</span>
<span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> fmap</code></pre>
</section>
<section id="applicative" class="slide level1">
<h1>Applicative</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a
  <span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;*&gt;</span>
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span>
  pure x <span class="fu">=</span> [x]
  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> concatMap (\f <span class="ot">-&gt;</span> map f xs) fs

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Just</span>
  <span class="dt">Just</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> x <span class="fu">=</span> <span class="dt">Just</span> (f x)
  _      <span class="fu">&lt;*&gt;</span> _      <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
</section>
<section id="monad" class="slide level1">
<h1>Monad</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  (&gt;&gt;)  ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
  ma <span class="fu">&gt;&gt;</span> mb <span class="fu">=</span> ma <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> mb

<span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>
  return <span class="fu">=</span> pure
  m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> concatMap f m

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  return <span class="fu">=</span> pure
  <span class="dt">Just</span> x  <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x
  <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
</section>
<section id="parser-combinators" class="slide level1">
<h1>Parser Combinators</h1>
</section>
<section id="parsing" class="slide level1">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">SJSON</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (concat)
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>, concat)
<span class="kw">import </span><span class="dt">Data.Attoparsec.Text</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">data</span> <span class="dt">JSON</span> <span class="fu">=</span> <span class="dt">JArray</span> [<span class="dt">JSON</span>]
          <span class="fu">|</span> <span class="dt">JObject</span> [(<span class="dt">Text</span>, <span class="dt">JSON</span>)]
          <span class="fu">|</span> <span class="dt">JText</span> <span class="dt">Text</span>
          <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">pJSON ::</span> <span class="dt">Parser</span> <span class="dt">JSON</span>
pJSON <span class="fu">=</span> choice [ pText, pObject, pArray ]
  <span class="kw">where</span>
    pString <span class="fu">=</span> concat <span class="fu">&lt;$&gt;</span> <span class="st">&quot;\&quot;&quot;</span> <span class="fu">.*&gt;</span> many pStringChunk <span class="fu">&lt;*.</span> <span class="st">&quot;\&quot;&quot;</span>
    pStringChunk <span class="fu">=</span> choice [ <span class="st">&quot;\\\&quot;&quot;</span> <span class="fu">.*&gt;</span> pure <span class="st">&quot;\&quot;&quot;</span>
                          , takeWhile1 (not <span class="fu">.</span> (<span class="ot">`elem`</span> <span class="st">&quot;\\\&quot;&quot;</span>))
                          , <span class="st">&quot;\\&quot;</span> ]
    pText <span class="fu">=</span> <span class="dt">JText</span> <span class="fu">&lt;$&gt;</span> pString
    pPair <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> pString <span class="fu">&lt;*.</span> <span class="st">&quot;:&quot;</span> <span class="fu">&lt;*&gt;</span> pJSON
    pObject <span class="fu">=</span> <span class="dt">JObject</span> <span class="fu">&lt;$&gt;</span> <span class="st">&quot;{&quot;</span> <span class="fu">.*&gt;</span> (pPair <span class="ot">`sepBy`</span> <span class="st">&quot;,&quot;</span>) <span class="fu">&lt;*.</span> <span class="st">&quot;}&quot;</span>
    pArray <span class="fu">=</span> <span class="dt">JArray</span> <span class="fu">&lt;$&gt;</span> <span class="st">&quot;[&quot;</span> <span class="fu">.*&gt;</span> (pJSON <span class="ot">`sepBy`</span> <span class="st">&quot;,&quot;</span>) <span class="fu">&lt;*.</span> <span class="st">&quot;]&quot;</span></code></pre>
</section>
<section id="why-not-haskell" class="slide level1">
<h1>Why not Haskell?</h1>
<ul>
<li>Lots of new terminology</li>
<li>Mutable state takes more effort</li>
<li>Laziness changes how you need to reason about code</li>
<li>Once you get used to it, these aren't problematic</li>
</ul>
</section>
<section id="terminology" class="slide level1">
<h1></h1>
<p><em>A monad is just a monoid in the category of endofunctors, what's the problem?</em></p>
<p>Terminology from category theory can be intimidating (at first)!</p>
<p><code>return</code> probably doesn't mean what you think it means.</p>
</section>
<section id="laziness-behavior-1" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
sum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum []     <span class="fu">=</span> <span class="dv">0</span>
sum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum xs</code></pre>
</section>
<section id="laziness-behavior-2" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Num</span> [a] <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go acc (x<span class="fu">:</span>xs) <span class="fu">=</span> go (acc <span class="fu">+</span> x) (go xs)
    go acc []     <span class="fu">=</span> acc</code></pre>
</section>
<section id="laziness-behavior-3" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Num</span> [a] <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go acc _
      <span class="fu">|</span> acc <span class="ot">`seq`</span> <span class="dt">False</span> <span class="fu">=</span> undefined
    go acc (x<span class="fu">:</span>xs)       <span class="fu">=</span> go (acc <span class="fu">+</span> x) (go xs)
    go acc []           <span class="fu">=</span> acc</code></pre>
</section>
<section id="laziness-behavior-4" class="slide level1 big-code">
<h1></h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>

sum<span class="ot"> ::</span> <span class="dt">Num</span> [a] <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go <span class="fu">!</span>acc (x<span class="fu">:</span>xs) <span class="fu">=</span> go (acc <span class="fu">+</span> x) (go xs)
    go  acc []     <span class="fu">=</span> acc</code></pre>
</section>
<section id="learn-more" class="slide level1">
<h1>Learn More</h1>
<dl>
<dt>Books</dt>
<dd><a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a>
</dd>
<dd><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a>
</dd>
<dd><a href="http://book.realworldhaskell.org/">Real World Haskell</a>
</dd>
<dt>Lectures</dt>
<dd><a href="http://www.seas.upenn.edu/~cis194/">Introduction to Haskell</a> - CIS 194 Spring 2013, UPenn
</dd>
<dd><a href="http://www.scs.stanford.edu/14sp-cs240h/">Functional Systems in Haskell</a> - CS240h Autumn 2014, Stanford
</dd>
<dd><a href="http://shuklan.com/haskell/index.html">Introduction to Haskell</a> - CS1501 Spring 2013, UVA
</dd>
<dd><a href="http://courses.cms.caltech.edu/cs11/material/haskell/">Haskell Track</a> - CS 11 Fall 2011, Caltech
</dd>
<dt>Practice</dt>
<dd><a href="http://exercism.io/">exercism.io</a>, <a href="http://www.talentbuddy.co/">Talentbuddy</a>, <a href="https://www.hackerrank.com/">HackerRank</a>
</dd>
<dd><a href="http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems">H-99</a>, <a href="http://projecteuler.net/">Project Euler</a>
</dd>
</dl>
</section>
<section id="thanks" class="slide level1">
<h1>Thanks!</h1>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 69%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Slides</strong></p></td>
<td style="text-align: left;"><p><a href="http://bob.ippoli.to/beginning-haskell-bayhac-2014/">bob.ippoli.to/beginning-haskell-bayhac-2014</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Source</strong></p></td>
<td style="text-align: left;"><p><a href="https://github.com/etrepum/beginning-haskell-bayhac-2014/">github.com/etrepum/beginning-haskell-bayhac-2014</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><strong>Email</strong></p></td>
<td style="text-align: left;"><p>bob@redivi.com</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Twitter</strong></p></td>
<td style="text-align: left;"><p><a href="https://twitter.com/etrepum">@etrepum</a></p></td>
</tr>
</tbody>
</table>
<!--
Other interesting presentations:
http://shuklan.com/haskell/lec01.html
http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf

TODO
http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
http://www.haskell.org/tutorial/goodies.html

-->
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,
        center: false,
        slideNumber: true,
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-30504730-1', 'ippoli.to');
  ga('send', 'pageview');

</script>
  </body>
</html>
